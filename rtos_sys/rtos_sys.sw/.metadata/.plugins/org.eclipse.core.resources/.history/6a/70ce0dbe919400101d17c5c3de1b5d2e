#include "xgpio.h"
#include "xaxidma.h"
#include "xparameters.h"
#include "xil_types.h"
#include "xscugic.h"
#include "sleep.h"
#include "xil_exception.h"
#include "xil_cache.h"
#include "xil_printf.h"
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include <string.h>

/* --- Periféricos y configuración --- */
XGpio_Config *GpioCfgPtr;
XGpio AxiGpio;
XAxiDma DMA0;
XAxiDma DMA1;
XAxiDma_Config *DMA0_CONFIG;
XAxiDma_Config *DMA1_CONFIG;

#define DMA0_DEVICE_ID      XPAR_AXIDMA_0_DEVICE_ID
#define DMA1_DEVICE_ID      XPAR_AXIDMA_1_DEVICE_ID
#define GPIO_DEV_ID         XPAR_GPIO_0_DEVICE_ID
#define DMA_TRANSFER_SIZE   64

u32 Length = sizeof(u64) * 64;
u32 num_elements = DMA_TRANSFER_SIZE / sizeof(u64);

u64 data_andespix_to_zynq[64];
u64 data_triggerumd_to_zynq[64];

UINTPTR BuffAddr0 = (UINTPTR)data_andespix_to_zynq;
UINTPTR BuffAddr1 = (UINTPTR)data_triggerumd_to_zynq;

u8 test_buf[65536];
u32 status;

/* --- FreeRTOS Sync --- */
SemaphoreHandle_t xDma0Semaphore;
SemaphoreHandle_t xDma1Semaphore;

/* --- Interrupciones --- */
extern XScuGic_Config *GicConfig;
extern XScuGic InterruptController;

#define INTC_DEVICE_ID      XPAR_SCUGIC_SINGLE_DEVICE_ID
#define DMA0_RX_INTR_ID     XPAR_FABRIC_AXI_DMA_0_S2MM_INTROUT_INTR
#define DMA1_RX_INTR_ID     XPAR_FABRIC_AXI_DMA_1_S2MM_INTROUT_INTR

/* --- Typedef callback si no está definido --- */
#ifndef XAxiDma_CallBackFn
typedef void (*XAxiDma_CallBackFn)(void *CallBackRef, u32 IrqMask, int *IgnorePtr);
#endif

/* --- Callbacks --- */
static void Dma0RxDoneCallback(void *CallBackRef, u32 IrqMask, int *IgnorePtr) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(xDma0Semaphore, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

static void Dma1RxDoneCallback(void *CallBackRef, u32 IrqMask, int *IgnorePtr) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(xDma1Semaphore, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/* --- ISRs DMA --- */
void Dma0IntrHandler(void *CallbackRef) {
    u32 IrqStatus;
    int Ignore = 0;

    IrqStatus = XAxiDma_IntrGetIrq(&DMA0, XAXIDMA_DEVICE_TO_DMA);
    XAxiDma_IntrAckIrq(&DMA0, IrqStatus, XAXIDMA_DEVICE_TO_DMA);

    if ((IrqStatus & XAXIDMA_IRQ_IOC_MASK) != 0) {
        Dma0RxDoneCallback(CallbackRef, IrqStatus, &Ignore);
    }
}

void Dma1IntrHandler(void *CallbackRef) {
    u32 IrqStatus;
    int Ignore = 0;

    IrqStatus = XAxiDma_IntrGetIrq(&DMA1, XAXIDMA_DEVICE_TO_DMA);
    XAxiDma_IntrAckIrq(&DMA1, IrqStatus, XAXIDMA_DEVICE_TO_DMA);

    if ((IrqStatus & XAXIDMA_IRQ_IOC_MASK) != 0) {
        Dma1RxDoneCallback(CallbackRef, IrqStatus, &Ignore);
    }
}

/* --- Inicialización GIC --- */
int InitInterrupts(void) {
    int Status;

    GicConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == GicConfig) {
        return XST_FAILURE;
    }

    Status = XScuGic_CfgInitialize(&InterruptController, GicConfig, GicConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    XScuGic_SetPriorityTriggerType(&InterruptController, DMA0_RX_INTR_ID, 0, 0x01);
    XScuGic_SetPriorityTriggerType(&InterruptController, DMA1_RX_INTR_ID, 0, 0x01);

    Status = XScuGic_Connect(&InterruptController, DMA0_RX_INTR_ID,
                             (Xil_InterruptHandler)Dma0IntrHandler, &DMA0);
    if (Status != XST_SUCCESS) {
        return Status;
    }

    Status = XScuGic_Connect(&InterruptController, DMA1_RX_INTR_ID,
                             (Xil_InterruptHandler)Dma1IntrHandler, &DMA1);
    if (Status != XST_SUCCESS) {
        return Status;
    }

    XScuGic_Enable(&InterruptController, DMA0_RX_INTR_ID);
    XScuGic_Enable(&InterruptController, DMA1_RX_INTR_ID);

    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 &InterruptController);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

/* --- Inicialización DMA + GPIO --- */
int dma_initialization(void) {
    Xil_DCacheFlushRange((UINTPTR)data_andespix_to_zynq, DMA_TRANSFER_SIZE);
    Xil_DCacheFlushRange((UINTPTR)data_triggerumd_to_zynq, DMA_TRANSFER_SIZE);

    if ((BuffAddr0 & 0x07) != 0) {
        xil_printf("Buffer address 0 is not 8-byte aligned!\n");
        return XST_FAILURE;
    }
    if ((BuffAddr1 & 0x07) != 0) {
        xil_printf("Buffer address 1 is not 8-byte aligned!\n");
        return XST_FAILURE;
    }

    GpioCfgPtr = XGpio_LookupConfig(GPIO_DEV_ID);
    if (!GpioCfgPtr) return XST_FAILURE;

    status = XGpio_CfgInitialize(&AxiGpio, GpioCfgPtr, GpioCfgPtr->BaseAddress);
    if (status != XST_SUCCESS) return XST_FAILURE;
    xil_printf("GPIO initialized.\r\n");

    DMA0_CONFIG = XAxiDma_LookupConfig(DMA0_DEVICE_ID);
    DMA1_CONFIG = XAxiDma_LookupConfig(DMA1_DEVICE_ID);

    if (!DMA0_CONFIG || !DMA1_CONFIG) {
        xil_printf("DMA LookupConfig error.\n");
        return XST_FAILURE;
    }

    status = XAxiDma_CfgInitialize(&DMA0, DMA0_CONFIG);
    if (status != XST_SUCCESS) {
        xil_printf("DMA0_CONFIG error.\r\n");
        return XST_FAILURE;
    }

    status = XAxiDma_CfgInitialize(&DMA1, DMA1_CONFIG);
    if (status != XST_SUCCESS) {
        xil_printf("DMA1_CONFIG error.\r\n");
        return XST_FAILURE;
    }

    /* Disable interrupts */
    XAxiDma_IntrDisable(&DMA0, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
    XAxiDma_IntrDisable(&DMA1, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);

    /* Register Callbacks */
    XAxiDma_SetCallBack(&DMA0, XAXIDMA_HANDLER_DONE,
                        (XAxiDma_CallBackFn)Dma0RxDoneCallback, &DMA0);
    XAxiDma_SetCallBack(&DMA1, XAXIDMA_HANDLER_DONE,
                        (XAxiDma_CallBackFn)Dma1RxDoneCallback, &DMA1);

    /* Enable interrupts */
    XAxiDma_IntrEnable(&DMA0, XAXIDMA_IRQ_IOC_MASK, XAXIDMA_DEVICE_TO_DMA);
    XAxiDma_IntrEnable(&DMA1, XAXIDMA_IRQ_IOC_MASK, XAXIDMA_DEVICE_TO_DMA);

    /* Init GIC */
    if (InitInterrupts() != XST_SUCCESS) {
        xil_printf("Interrupts init failed.\r\n");
        return XST_FAILURE;
    }

    /* Semaphores */
    xDma0Semaphore = xSemaphoreCreateBinary();
    xDma1Semaphore = xSemaphoreCreateBinary();
    if (xDma0Semaphore == NULL || xDma1Semaphore == NULL) {
        xil_printf("Semaphore creation failed.\r\n");
        return XST_FAILURE;
    }

    xil_printf("DMA0 & DMA1 initialized OK.\n");
    XGpio_DiscreteWrite(&AxiGpio, 1, 0);

    return XST_SUCCESS;
}

/* --- Task FreeRTOS --- */
void vDmaTask(void *pvParameters) {
    for (;;) {
        vTaskDelay(pdMS_TO_TICKS(1000));  // Espera antes de iniciar

        /* DMA0 Transfer */
        XGpio_DiscreteWrite(&AxiGpio, 1, 1);
        status = XAxiDma_SimpleTransfer(&DMA0, BuffAddr0, Length, XAXIDMA_DEVICE_TO_DMA);
        if (status != XST_SUCCESS) {
            xil_printf("DMA0 transfer failed!\r\n");
            continue;
        }
        if (xSemaphoreTake(xDma0Semaphore, portMAX_DELAY) == pdTRUE) {
            xil_printf("Data DMA0 (Andespix -> Zynq):\n");
            for (u32 i = 0; i < num_elements; i++) {
                xil_printf("[%d] = 0x%016llX\r\n", i, data_andespix_to_zynq[i]);
            }
        }

        /* DMA1 Transfer */
        status = XAxiDma_SimpleTransfer(&DMA1, BuffAddr1, Length, XAXIDMA_DEVICE_TO_DMA);
        if (status != XST_SUCCESS) {
            xil_printf("DMA1 transfer failed!\r\n");
            continue;
        }
        if (xSemaphoreTake(xDma1Semaphore, portMAX_DELAY) == pdTRUE) {
            xil_printf("Data DMA1 (TriggerUMD -> Zynq):\n");
            for (u32 i = 0; i < num_elements; i++) {
                xil_printf("[%d] = 0x%016llX\r\n", i, data_triggerumd_to_zynq[i]);
            }
            dma_data_ready_callback();
        }

        reset_gpio();
    }
}

/* --- Utils --- */
void reset_gpio(void) {
    XGpio_DiscreteWrite(&AxiGpio, 1, 0);
    usleep(20);
    XGpio_DiscreteWrite(&AxiGpio, 1, 1);

    for (int i = 0; i < DMA_TRANSFER_SIZE; i++) {
        data_andespix_to_zynq[i] = 0;
        data_triggerumd_to_zynq[i] = 0;
    }
}

int dma_data_ready_callback(void) {
    memcpy(&test_buf[0], data_andespix_to_zynq, num_elements * sizeof(u64));
    memcpy(&test_buf[num_elements], data_triggerumd_to_zynq, num_elements * sizeof(u64));
    return XST_SUCCESS;
}

