#include "iic_task.h"
#include "xparameters.h"
#include "xil_types.h"
#include "xil_printf.h"
#include "xscugic.h"
#include "xiicps.h"
#include "sleep.h"

#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"

/* ------------ Constants ------------ */
#define INTC_DEVICE_ID      XPAR_SCUGIC_SINGLE_DEVICE_ID
#define IIC_INT_VEC_ID      XPAR_XIICPS_0_INTR
#define IIC_SLAVE_ADDR      0x20
#define IIC_SCLK_RATE       10000

static void IicTask(void *pvParameters);
static int init_iic(void);
static int SetupInterruptSystem_iic(XIicPs *IicPsPtr);
void I2C_InterruptHandler(void *CallBackRef, u32 Event);

XIicPs IicInstance;
XIicPs_Config *ConfigPtr;
extern XScuGic InterruptController;
extern XScuGic_Config *GicConfig;

static volatile u32 SendComplete;
static volatile u32 RecvComplete;
static volatile u32 TotalErrorCount;
static volatile u32 NACKreceive;
u8 buffer_config [1024];
/* FreeRTOS primitives */
static SemaphoreHandle_t xIicEventSem;

u8 FirstBuffer[3];

BaseType_t StartIICTask(void)
{
    xIicEventSem = xSemaphoreCreateBinary();
    if (xIicEventSem == NULL) {
        xil_printf("Failed to create IIC semaphore\r\n");
        return pdFAIL;
    }

    return xTaskCreate(IicTask, "IIC_TASK", 4096, NULL, tskIDLE_PRIORITY + 2, NULL);
}

static void IicTask(void *pvParameters)
{
    (void) pvParameters;
    int status;

    xil_printf("IIC Task starting...\r\n");

    status = init_iic();
    if (status != XST_SUCCESS) {
        xil_printf("init_iic failed\r\n");
        vTaskDelete(NULL);
    }

    XIicPs_SetStatusHandler(&IicInstance, &IicInstance, (XIicPs_IntrHandler)I2C_InterruptHandler);


    status = SetupInterruptSystem_iic(&IicInstance);
    if (status != XST_SUCCESS) {
        xil_printf("SetupInterruptSystem_iic failed\r\n");
        vTaskDelete(NULL);
    }

    /* Set clock */
    XIicPs_SetSClk(&IicInstance, IIC_SCLK_RATE);

    FirstBuffer[0] = 0x06;
    FirstBuffer[1] = 0x00; /* CONFIG_P0 */
    FirstBuffer[2] = 0xF1; /* CONFIG_P1 */

    {
        u8 datasop[3];
        RecvComplete = FALSE;
        NACKreceive = FALSE;
        SendComplete = FALSE;

        XIicPs_MasterRecv(&IicInstance, datasop, 3, IIC_SLAVE_ADDR);

        if (xSemaphoreTake(xIicEventSem, pdMS_TO_TICKS(200)) == pdTRUE) {
            xil_printf("Received: ");
            for (int i=0; i<3; ++i) xil_printf("%02X ", datasop[i]);
            xil_printf("\r\n");
        } else {
            xil_printf("Timeout waiting for initial recv\r\n");
        }
    }

    {
        SendComplete = FALSE;
        XIicPs_MasterSend(&IicInstance, FirstBuffer, 3, IIC_SLAVE_ADDR);

        if (xSemaphoreTake(xIicEventSem, pdMS_TO_TICKS(200)) == pdTRUE) {
            xil_printf("Configuration to TCAL successful\r\n");
        } else {
            xil_printf("Timeout waiting for send complete\r\n");
        }
    }

    {
        u8 datasop[3];
        RecvComplete = FALSE;
        XIicPs_MasterRecv(&IicInstance, datasop, 3, IIC_SLAVE_ADDR);
        if (xSemaphoreTake(xIicEventSem, pdMS_TO_TICKS(200)) == pdTRUE) {
            for (int inx = 0; inx < 3; inx++) xil_printf("%02X", datasop[inx]);
            xil_printf("\r\n");
        } else {
            xil_printf("Timeout waiting for recv\r\n");
        }
    }

    for (int contador = 0; contador < 252; contador++) {
        u8 bufer[9];
        bufer[0] =  0x02;
        bufer[1] = (1 << 1) * buffer_config[contador];
        bufer[2] = 0x00;
        bufer[3] = (1 << 1) * buffer_config[contador] + (1 << 3);
        bufer[4] = 0x00;
        bufer[5] = (1 << 1) * buffer_config[contador];
        bufer[6] = 0x00;
        bufer[7] = (1 << 1) * buffer_config[contador] + (1 << 4);
        bufer[8] = 0x00;

        XIicPs_MasterSend(&IicInstance, bufer , 9, IIC_SLAVE_ADDR);

        if (xSemaphoreTake(xIicEventSem, pdMS_TO_TICKS(100)) == pdTRUE) {
            /* ok */
        } else {
            xil_printf("Timeout sending block %d\r\n", contador);
        }


        vTaskDelay(pdMS_TO_TICKS(1));
    }

    {
        u8 ld_buffer[7];
        ld_buffer[0] = 0x02;
        ld_buffer[1] = 0x00;
        ld_buffer[2] = 0x00;
        ld_buffer[3] = 0x04;
        ld_buffer[4] = 0x00;
        ld_buffer[5] = 0x00;
        ld_buffer[6] = 0x00;
        XIicPs_MasterSend(&IicInstance, ld_buffer, 7, IIC_SLAVE_ADDR);
        if (xSemaphoreTake(xIicEventSem, pdMS_TO_TICKS(200)) == pdTRUE) {
            xil_printf("LD buffer sent\r\n");
        } else {
            xil_printf("Timeout waiting LD send\r\n");
        }
    }

    xil_printf("Configuration to ANDESPix successful\r\n");

    vTaskDelete(NULL);
}

static int init_iic(void) {
    xil_printf("LookupConfig...\r\n");
    ConfigPtr = XIicPs_LookupConfig(XPAR_XIICPS_0_DEVICE_ID);

    if (ConfigPtr == NULL) {
        xil_printf("LookupConfig failed!\r\n");
        return XST_FAILURE;
    }

    xil_printf("CfgInitialize...\r\n");
    int status = XIicPs_CfgInitialize(&IicInstance, ConfigPtr, ConfigPtr->BaseAddress);
    if (status != XST_SUCCESS) {
        xil_printf("CfgInitialize failed!\r\n");
        return XST_FAILURE;
    }

    xil_printf("IIC Initialized\r\n");
    return XST_SUCCESS;
}

static int SetupInterruptSystem_iic(XIicPs *IicPsPtr)
{
    int Status;

    GicConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
    if (NULL == GicConfig) {
        return XST_FAILURE;
    }

    Status = XScuGic_CfgInitialize(&InterruptController, GicConfig, GicConfig->CpuBaseAddress);
    if (Status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    Status = XScuGic_SelfTest(&InterruptController);
    if (Status != XST_SUCCESS) {
        return XST_FAILURE;
    }
    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT, (Xil_ExceptionHandler) XScuGic_InterruptHandler, &InterruptController);
    Xil_ExceptionEnable();

    Status = XScuGic_Connect(&InterruptController, IIC_INT_VEC_ID, (Xil_ExceptionHandler) XIicPs_MasterInterruptHandler, (void *)IicPsPtr);
    if (Status != XST_SUCCESS) {
        xil_printf("XScuGic_Connect failed\r\n");
        return XST_FAILURE;
    }

    XScuGic_Enable(&InterruptController, IIC_INT_VEC_ID);
    return XST_SUCCESS;
}

void I2C_InterruptHandler(void *CallBackRef, u32 Event)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    if (0 != (Event & XIICPS_EVENT_COMPLETE_RECV)) {
        RecvComplete = TRUE;
        xSemaphoreGiveFromISR(xIicEventSem, &xHigherPriorityTaskWoken);
    } else if (0 != (Event & XIICPS_EVENT_COMPLETE_SEND)) {
        SendComplete = TRUE;
        xSemaphoreGiveFromISR(xIicEventSem, &xHigherPriorityTaskWoken);
    } else {
        if (0 != (Event & XIICPS_EVENT_TIME_OUT)) {
            TotalErrorCount++;
            xil_printf("Error: Transfer timed out\n");
        }
        if (0 != (Event & XIICPS_EVENT_NACK)) {
            NACKreceive = TRUE;
            xil_printf("NACK Received\n");
        }
    }

    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
